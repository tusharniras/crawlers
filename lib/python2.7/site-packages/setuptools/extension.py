<<<<<<< HEAD
import sys
=======
>>>>>>> 9459088bb25ddc25dfea5e6c10b301c783669fad
import re
import functools
import distutils.core
import distutils.errors
import distutils.extension

<<<<<<< HEAD
from .dist import _get_unpatched
from . import msvc9_support

_Extension = _get_unpatched(distutils.core.Extension)

msvc9_support.patch_for_specialized_compiler()

def have_pyrex():
    """
    Return True if Cython or Pyrex can be imported.
    """
    pyrex_impls = 'Cython.Distutils.build_ext', 'Pyrex.Distutils.build_ext'
    for pyrex_impl in pyrex_impls:
        try:
            # from (pyrex_impl) import build_ext
            __import__(pyrex_impl, fromlist=['build_ext']).build_ext
            return True
        except Exception:
            pass
    return False


class Extension(_Extension):
    """Extension that uses '.c' files in place of '.pyx' files"""

    def __init__(self, *args, **kw):
        _Extension.__init__(self, *args, **kw)
        self._convert_pyx_sources_to_lang()
=======
from setuptools.extern.six.moves import map

from .monkey import get_unpatched


def _have_cython():
    """
    Return True if Cython can be imported.
    """
    cython_impl = 'Cython.Distutils.build_ext'
    try:
        # from (cython_impl) import build_ext
        __import__(cython_impl, fromlist=['build_ext']).build_ext
        return True
    except Exception:
        pass
    return False


# for compatibility
have_pyrex = _have_cython


_Extension = get_unpatched(distutils.core.Extension)


class Extension(_Extension):
    """Extension that uses '.c' files in place of '.pyx' files"""

    def __init__(self, name, sources, *args, **kw):
        # The *args is needed for compatibility as calls may use positional
        # arguments. py_limited_api may be set only via keyword.
        self.py_limited_api = kw.pop("py_limited_api", False)
        _Extension.__init__(self, name, sources, *args, **kw)
>>>>>>> 9459088bb25ddc25dfea5e6c10b301c783669fad

    def _convert_pyx_sources_to_lang(self):
        """
        Replace sources with .pyx extensions to sources with the target
        language extension. This mechanism allows language authors to supply
        pre-converted sources but to prefer the .pyx sources.
        """
<<<<<<< HEAD
        if have_pyrex():
=======
        if _have_cython():
>>>>>>> 9459088bb25ddc25dfea5e6c10b301c783669fad
            # the build has Cython, so allow it to compile the .pyx files
            return
        lang = self.language or ''
        target_ext = '.cpp' if lang.lower() == 'c++' else '.c'
        sub = functools.partial(re.sub, '.pyx$', target_ext)
        self.sources = list(map(sub, self.sources))

<<<<<<< HEAD
class Library(Extension):
    """Just like a regular Extension, but built as a library instead"""

distutils.core.Extension = Extension
distutils.extension.Extension = Extension
if 'distutils.command.build_ext' in sys.modules:
    sys.modules['distutils.command.build_ext'].Extension = Extension
=======

class Library(Extension):
    """Just like a regular Extension, but built as a library instead"""
>>>>>>> 9459088bb25ddc25dfea5e6c10b301c783669fad
